name: Deploy to Staging and Production
on:
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types: [completed]
    branches: [main]
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: "Force deployment (skip health checks)"
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')

    environment:
      name: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}

      - name: Deploy to staging server
        id: deploy
        run: |
          # Copy deployment files to staging server
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:~/
          scp -o StrictHostKeyChecking=no .env-example ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:~/

          # Deploy on staging server
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ENDSSH'
            # Set environment variables
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            export IMAGE_TAG="latest"
            export CLIENT_ENV="staging"
            export CLIENT_IMAGE_TAG="latest-staging"

            # Create staging environment file from template
            cp .env-example .env

            # Set staging-specific values
            sed -i "s|GROQ_API_KEY=.*|GROQ_API_KEY=${{ secrets.STAGING_GROQ_API_KEY }}|" .env
            sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=${{ secrets.STAGING_REDIS_PASSWORD }}|" .env
            sed -i "s|CORS_ORIGINS=.*|CORS_ORIGINS=http://${{ secrets.STAGING_HOST }}:3000,http://client:3000|" .env

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull latest images
            docker compose -f docker-compose.prod.yml pull

            # Deploy with zero-downtime
            docker compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            timeout 300s bash -c 'until docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; do sleep 5; done'

            # Cleanup old images
            docker image prune -f
          ENDSSH

      - name: Run health checks
        run: |
          # Wait for services to be ready
          sleep 60

          # Check API health
          curl -f http://${{ secrets.STAGING_HOST }}:8000/health || exit 1

          # Check client health
          curl -f http://${{ secrets.STAGING_HOST }}:3000 || exit 1

          # Test token endpoint
          curl -f -X POST http://${{ secrets.STAGING_HOST }}:8000/token -d "name=test-user" || exit 1

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        if: success()
        with:
          status: success
          text: "‚úÖ Staging deployment successful! URL: http://${{ secrets.STAGING_HOST }}:3000"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy-production:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')

    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Create deployment backup
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Create backup of current deployment
            BACKUP_DIR="backup_$(date +%Y%m%d_%H%M%S)"
            mkdir -p $BACKUP_DIR

            # Backup database if Redis has persistence enabled
            docker compose exec redis redis-cli -a ${{ secrets.PRODUCTION_REDIS_PASSWORD }} BGSAVE || true

            # Backup environment and compose files
            cp -r .env docker-compose.prod.yml $BACKUP_DIR/ || true

            echo "Backup created in $BACKUP_DIR"
          ENDSSH

      - name: Deploy to production
        id: deploy
        run: |
          # Get the tag name for production deployment
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Extract tag and remove 'v' prefix if present to match docker metadata action
            FULL_TAG=${GITHUB_REF#refs/tags/}
            IMAGE_TAG=${FULL_TAG#v}
          else
            IMAGE_TAG="latest"
          fi



          # Copy deployment files to production server
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:~/
          scp -o StrictHostKeyChecking=no .env-example ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:~/

          # Deploy on production server
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << ENDSSH
            # Set environment variables for docker compose
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            export IMAGE_TAG="$IMAGE_TAG"
            export CLIENT_ENV="production"
            export CLIENT_IMAGE_TAG="$IMAGE_TAG-production"

            # Create production environment file from template
            cp .env-example .env

            # Set production-specific values
            sed -i "s|GROQ_API_KEY=.*|GROQ_API_KEY=${{ secrets.PRODUCTION_GROQ_API_KEY }}|" .env
            sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=${{ secrets.PRODUCTION_REDIS_PASSWORD }}|" .env
            sed -i "s|CORS_ORIGINS=.*|CORS_ORIGINS=https://${{ secrets.PRODUCTION_DOMAIN }},http://client:3000|" .env

            # Add production-specific variables
            echo "NODE_ENV=production" >> .env

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Debug: Show what images we're trying to pull
            echo "=== Production Deployment Configuration ==="
            echo "REGISTRY: \$REGISTRY"
            echo "IMAGE_NAME: \$IMAGE_NAME"
            echo "IMAGE_TAG: \$IMAGE_TAG"
            echo "CLIENT_ENV: \$CLIENT_ENV"
            echo "CLIENT_IMAGE_TAG: \$CLIENT_IMAGE_TAG"
            echo ""
            echo "=== Expected Images ==="
            echo "Server: \$REGISTRY/\$IMAGE_NAME/server:\$IMAGE_TAG"
            echo "Worker: \$REGISTRY/\$IMAGE_NAME/worker:\$IMAGE_TAG"
            echo "Client: \$REGISTRY/\$IMAGE_NAME/client:\$CLIENT_IMAGE_TAG"
            echo ""

            # Try to pull images individually to see which ones fail
            echo "=== Pulling Server Image ==="
            docker pull \$REGISTRY/\$IMAGE_NAME/server:\$IMAGE_TAG || echo "Failed to pull server image"

            echo "=== Pulling Worker Image ==="
            docker pull \$REGISTRY/\$IMAGE_NAME/worker:\$IMAGE_TAG || echo "Failed to pull worker image"

            echo "=== Pulling Client Image ==="
            docker pull \$REGISTRY/\$IMAGE_NAME/client:\$CLIENT_IMAGE_TAG || echo "Failed to pull client image"

            # Pull specific version images
            docker compose -f docker-compose.prod.yml pull

            # Rolling deployment with health checks
            docker compose -f docker-compose.prod.yml up -d --wait

            # Verify deployment
            timeout 300s bash -c 'until docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; do sleep 5; done'

            # Cleanup old images (keep last 3 versions)
            docker images | grep ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | sort -k2 -V | head -n -3 | awk '{print \$3}' | xargs -r docker rmi || true
          ENDSSH

      - name: Run production health checks
        if: ${{ !github.event.inputs.force_deploy }}
        run: |
          # Wait for services to be ready
          sleep 60

          # Check API health
          curl -f https://${{ secrets.PRODUCTION_DOMAIN }}/api/health || exit 1

          # Check client health
          curl -f https://${{ secrets.PRODUCTION_DOMAIN }} || exit 1

          # Run basic functionality test
          TOKEN_RESPONSE=$(curl -f -X POST http://${{ secrets.PRODUCTION_DOMAIN }}/api/token -d "name=test-user")
          if [[ $? -ne 0 ]]; then
            echo "‚ùå Token endpoint failed"
            exit 1
          fi

          echo "‚úÖ All health checks passed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back deployment due to health check failure"
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Find latest backup
            LATEST_BACKUP=$(ls -t | grep "backup_" | head -n 1)
            if [[ -n "$LATEST_BACKUP" ]]; then
              echo "Rolling back to $LATEST_BACKUP"

              # Restore files
              cp $LATEST_BACKUP/.env . || true
              cp $LATEST_BACKUP/docker-compose.prod.yml . || true

              # Restart services with previous version
              docker compose -f docker-compose.prod.yml up -d

              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup found for rollback"
            fi
          ENDSSH

      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "üöÄ Production deployment successful! URL: https://${{ secrets.PRODUCTION_DOMAIN }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify deployment failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: "‚ùå Production deployment failed! Check logs and rollback initiated."
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # # Cleanup job to remove old artifacts
  # cleanup:
  #   runs-on: ubuntu-latest
  #   needs: [deploy-staging, deploy-production]
  #   if: always()

  #   steps:
  #     - name: Cleanup old packages
  #       uses: actions/github-script@v6
  #       with:
  #         script: |
  #           const services = ['server', 'worker', 'client'];

  #           for (const service of services) {
  #             const packageName = `ai-chatbot/${service}`;

  #             const packages = await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
  #               package_type: 'container',
  #               package_name: packageName,
  #               username: context.repo.owner,
  #             });

  #             // Sort by created_at descending (newest first)
  #             const sorted = packages.data.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

  #             // Keep last 30 versions, delete older ones
  #             const versionsToDelete = sorted.slice(30);

  #             console.log(`üì¶ Found ${packages.data.length} versions for ${service}, deleting ${versionsToDelete.length} old versions`);

  #             for (const version of versionsToDelete) {
  #               await github.rest.packages.deletePackageVersionForUser({
  #                 package_type: 'container',
  #                 package_name: packageName,
  #                 username: context.repo.owner,
  #                 package_version_id: version.id,
  #               });
  #             }
  #           }
