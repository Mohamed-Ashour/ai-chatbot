name: Deploy
on:
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types: [completed]
    branches: [main]
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: "Force deployment (skip health checks)"
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: write

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')

    environment:
      name: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}

      - name: Deploy to staging server
        id: deploy
        run: |
          # Copy deployment files to staging server
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:~/
          scp -o StrictHostKeyChecking=no .env-example ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:~/

          # Deploy on staging server
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ENDSSH'
            # Set environment variables
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            export IMAGE_TAG="latest"
            export CLIENT_ENV="staging"
            export CLIENT_IMAGE_TAG="latest-staging"

            # Create staging environment file from template
            cp .env-example .env

            # Set staging-specific values
            sed -i "s|GROQ_API_KEY=.*|GROQ_API_KEY=${{ secrets.STAGING_GROQ_API_KEY }}|" .env
            sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=${{ secrets.STAGING_REDIS_PASSWORD }}|" .env
            sed -i "s|CORS_ORIGINS=.*|CORS_ORIGINS=http://${{ secrets.STAGING_HOST }}:3000,http://client:3000|" .env

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull latest images
            docker compose -f docker-compose.prod.yml pull

            # Deploy with zero-downtime
            docker compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            timeout 300s bash -c 'until docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; do sleep 5; done'

            # Cleanup old images
            docker image prune -f
          ENDSSH

      - name: Run health checks
        run: |
          # Wait for services to be ready
          sleep 60

          # Check API health
          curl -f http://${{ secrets.STAGING_HOST }}:8000/health || exit 1

          # Check client health
          curl -f http://${{ secrets.STAGING_HOST }}:3000 || exit 1

          # Test token endpoint
          curl -f -X POST http://${{ secrets.STAGING_HOST }}:8000/token -d "name=test-user" || exit 1

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        if: success()
        with:
          status: success
          text: "‚úÖ Staging deployment successful! URL: http://${{ secrets.STAGING_HOST }}:3000"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy-production:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')

    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Create deployment backup
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Create backup of current deployment
            BACKUP_DIR="backup_$(date +%Y%m%d_%H%M%S)"
            mkdir -p $BACKUP_DIR

            # Backup database if Redis has persistence enabled
            docker compose exec redis redis-cli -a ${{ secrets.PRODUCTION_REDIS_PASSWORD }} BGSAVE || true

            # Backup environment and compose files
            cp -r .env docker-compose.prod.yml $BACKUP_DIR/ || true

            echo "Backup created in $BACKUP_DIR"
          ENDSSH

      - name: Deploy to production
        id: deploy
        run: |
          # Get the tag name for production deployment
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Extract tag and remove 'v' prefix if present to match docker metadata action
            FULL_TAG=${GITHUB_REF#refs/tags/}
            IMAGE_TAG=${FULL_TAG#v}
          else
            IMAGE_TAG="latest"
          fi

          # Copy deployment files to production server
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:~/
          scp -o StrictHostKeyChecking=no .env-example ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:~/

          # Deploy on production server
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << ENDSSH
            # Set environment variables for docker compose
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            export IMAGE_TAG="$IMAGE_TAG"
            export CLIENT_ENV="production"
            export CLIENT_IMAGE_TAG="$IMAGE_TAG-production"

            # Create production environment file from template
            cp .env-example .env

            # Set production-specific values
            sed -i "s|GROQ_API_KEY=.*|GROQ_API_KEY=${{ secrets.PRODUCTION_GROQ_API_KEY }}|" .env
            sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=${{ secrets.PRODUCTION_REDIS_PASSWORD }}|" .env
            sed -i "s|CORS_ORIGINS=.*|CORS_ORIGINS=https://${{ secrets.PRODUCTION_DOMAIN }},http://client:3000|" .env

            # Add production-specific variables
            echo "NODE_ENV=production" >> .env

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull specific version images
            docker compose -f docker-compose.prod.yml pull

            # Rolling deployment with health checks
            docker compose -f docker-compose.prod.yml up -d --wait

            # Verify deployment
            timeout 300s bash -c 'until docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; do sleep 5; done'

            # Cleanup old images (keep last 3 versions)
            docker images | grep ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | sort -k2 -V | head -n -3 | awk '{print \$3}' | xargs -r docker rmi || true
          ENDSSH

      - name: Run production health checks
        if: ${{ !github.event.inputs.force_deploy }}
        run: |
          # Wait for services to be ready
          sleep 60

          # Check API health
          curl -f https://${{ secrets.PRODUCTION_DOMAIN }}/api/health || exit 1

          # Check client health
          curl -f https://${{ secrets.PRODUCTION_DOMAIN }} || exit 1

          # Run basic functionality test
          TOKEN_RESPONSE=$(curl -f -X POST https://${{ secrets.PRODUCTION_DOMAIN }}/api/token -d "name=test-user")
          if [[ $? -ne 0 ]]; then
            echo "‚ùå Token endpoint failed"
            exit 1
          fi

          echo "‚úÖ All health checks passed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back deployment due to health check failure"
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Find latest backup
            LATEST_BACKUP=$(ls -t | grep "backup_" | head -n 1)
            if [[ -n "$LATEST_BACKUP" ]]; then
              echo "Rolling back to $LATEST_BACKUP"

              # Restore files
              cp $LATEST_BACKUP/.env . || true
              cp $LATEST_BACKUP/docker-compose.prod.yml . || true

              # Restart services with previous version
              docker compose -f docker-compose.prod.yml up -d

              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup found for rollback"
            fi
          ENDSSH

      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "üöÄ Production deployment successful! URL: https://${{ secrets.PRODUCTION_DOMAIN }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify deployment failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: "‚ùå Production deployment failed! Check logs and rollback initiated."
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Cleanup job to remove old artifacts
  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    strategy:
      matrix:
        service: [server, worker, client]
      fail-fast: false

    steps:
      - name: Check if ${{ matrix.service }} package exists
        id: check-package
        continue-on-error: true
        run: |
          # The package name for delete-package-versions action
          # Extract just the repo name (without owner) for package name
          REPO_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2 | tr '[:upper:]' '[:lower:]')
          PACKAGE_NAME="${REPO_NAME}/${{ matrix.service }}"
          echo "Checking package: $PACKAGE_NAME"

          # Check if package exists
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/users/${{ github.repository_owner }}/packages/container/${PACKAGE_NAME/\//%2F}")

          if [[ "$RESPONSE" == "200" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "package-name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Delete untagged ${{ matrix.service }} packages
        if: steps.check-package.outputs.exists == 'true'
        uses: actions/delete-package-versions@v5
        continue-on-error: true
        with:
          package-name: "${{ steps.check-package.outputs.package-name }}"
          package-type: "container"
          delete-only-untagged-versions: true
          min-versions-to-keep: 5
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old tagged ${{ matrix.service }} packages
        if: steps.check-package.outputs.exists == 'true'
        uses: actions/delete-package-versions@v5
        continue-on-error: true
        with:
          package-name: "${{ steps.check-package.outputs.package-name }}"
          package-type: "container"
          min-versions-to-keep: 10
          ignore-versions: "^(latest|main|staging|production)$"
          token: ${{ secrets.GITHUB_TOKEN }}
