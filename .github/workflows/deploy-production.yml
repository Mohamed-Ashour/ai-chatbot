name: Deploy to Production
on:
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment (skip health checks)"
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Backup current deployment state
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Create backup directory with timestamp
            BACKUP_DIR="backup_$(date +%Y%m%d_%H%M%S)"
            mkdir -p $BACKUP_DIR

            # Save current image tags for rollback
            if docker compose ps > /dev/null 2>&1; then
              docker compose images --format json > $BACKUP_DIR/deployment_backup.json

              # Backup current compose and env files
              cp docker-compose.prod.yml $BACKUP_DIR/ 2>/dev/null || echo "No compose file to backup"
              cp .env $BACKUP_DIR/ 2>/dev/null || echo "No env file to backup"

              # Create a symlink to latest backup for easy access
              ln -sfn $BACKUP_DIR latest_backup

              echo "‚úÖ Current deployment state backed up to $BACKUP_DIR"
            else
              echo "No existing deployment to backup"
            fi
          ENDSSH

      - name: Deploy to production
        id: deploy
        run: |
          # Get the tag name for production deployment
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Extract tag and remove 'v' prefix if present to match docker metadata action
            FULL_TAG=${GITHUB_REF#refs/tags/}
            IMAGE_TAG=${FULL_TAG#v}
          else
            IMAGE_TAG="latest"
          fi

          # Copy deployment files to production server
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:~/
          scp -o StrictHostKeyChecking=no .env-example ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:~/

          # Deploy on production server
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << ENDSSH
            # Set environment variables for docker compose
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            export IMAGE_TAG="$IMAGE_TAG"
            export CLIENT_ENV="production"
            export CLIENT_IMAGE_TAG="$IMAGE_TAG-production"

            # Create production environment file from template
            cp .env-example .env

            # Set production-specific values
            sed -i "s|GROQ_API_KEY=.*|GROQ_API_KEY=${{ secrets.PRODUCTION_GROQ_API_KEY }}|" .env
            sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=${{ secrets.PRODUCTION_REDIS_PASSWORD }}|" .env
            sed -i "s|CORS_ORIGINS=.*|CORS_ORIGINS=https://${{ secrets.PRODUCTION_DOMAIN }},http://client:3000|" .env

            # Add production-specific variables
            echo "NODE_ENV=production" >> .env

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # Pull new images
            docker compose -f docker-compose.prod.yml pull

            # Rolling deployment with health checks
            docker compose -f docker-compose.prod.yml up -d --wait

            # Verify deployment
            timeout 300s bash -c 'until docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; do sleep 5; done'

            # Cleanup images after successful deployment
            echo "üßπ Cleaning up old images..."
            docker image prune -f || true

            echo "‚úÖ Deployment completed successfully"
          ENDSSH

      - name: Run production health checks
        if: ${{ !github.event.inputs.force_deploy }}
        run: |
          # Wait for services to be ready
          sleep 60

          # Check API health
          curl -f https://${{ secrets.PRODUCTION_DOMAIN }}/api/health || exit 1

          # Check client health
          curl -f https://${{ secrets.PRODUCTION_DOMAIN }} || exit 1

          # Run basic functionality test
          TOKEN_RESPONSE=$(curl -f -X POST https://${{ secrets.PRODUCTION_DOMAIN }}/api/token -d "name=test-user")
          if [[ $? -ne 0 ]]; then
            echo "‚ùå Token endpoint failed"
            exit 1
          fi

          echo "‚úÖ All health checks passed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back deployment due to health check failure"
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Check if we have a backup to rollback to
            if [[ -L "latest_backup" && -d "$(readlink latest_backup)" ]]; then
              BACKUP_DIR=$(readlink latest_backup)
              echo "Found previous deployment backup in $BACKUP_DIR, attempting rollback..."

              # Extract previous tag from backup (use server container as reference)
              PREV_TAG=$(jq -r '.[] | select(.ContainerName | contains("server")) | .Tag' $BACKUP_DIR/deployment_backup.json 2>/dev/null || echo "")

              if [[ -n "$PREV_TAG" ]]; then
                echo "Rolling back to previous version: $PREV_TAG"

                # Stop current failed deployment
                docker compose -f docker-compose.prod.yml down || true

                # Restore previous compose and env files
                if [[ -f "$BACKUP_DIR/docker-compose.prod.yml" ]]; then
                  cp $BACKUP_DIR/docker-compose.prod.yml .
                  echo "Restored previous docker-compose.prod.yml"
                fi

                if [[ -f "$BACKUP_DIR/.env" ]]; then
                  cp $BACKUP_DIR/.env .
                  echo "Restored previous .env file"
                fi

                # Set environment variables to previous version
                export REGISTRY="${{ env.REGISTRY }}"
                export IMAGE_NAME="${{ env.IMAGE_NAME }}"
                export IMAGE_TAG="$PREV_TAG"
                export CLIENT_ENV="production"
                export CLIENT_IMAGE_TAG="$PREV_TAG-production"

                # Start previous version
                docker compose -f docker-compose.prod.yml up -d

                # Wait for services to come up
                timeout 180s bash -c 'until docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; do sleep 5; done' || echo "‚ö†Ô∏è  Warning: Services may not be fully healthy after rollback"

                echo "‚úÖ Rollback completed to version $PREV_TAG"
              else
                echo "‚ùå Could not extract previous image information from backup"
                echo "Attempting emergency restart..."
                docker compose -f docker-compose.prod.yml restart
              fi
            else
              echo "‚ùå No deployment backup found"
              echo "Attempting emergency restart of current deployment..."
              docker compose -f docker-compose.prod.yml restart
            fi
          ENDSSH

      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "üöÄ Production deployment successful! URL: https://${{ secrets.PRODUCTION_DOMAIN }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify deployment failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: "‚ùå Production deployment failed! Check logs and rollback initiated."
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Cleanup job to remove old artifacts
  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    strategy:
      matrix:
        service: [server, worker, client]
      fail-fast: false

    steps:
      - name: Delete untagged ${{ matrix.service }} packages
        uses: actions/delete-package-versions@v5
        continue-on-error: true
        with:
          package-name: "${{ github.event.repository.name }}/${{ matrix.service }}"
          package-type: "container"
          delete-only-untagged-versions: true
          min-versions-to-keep: 5
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old tagged ${{ matrix.service }} packages
        uses: actions/delete-package-versions@v5
        continue-on-error: true
        with:
          package-name: "${{ github.event.repository.name }}/${{ matrix.service }}"
          package-type: "container"
          min-versions-to-keep: 10
          ignore-versions: "^(latest|main|staging|production)$"
          token: ${{ secrets.GITHUB_TOKEN }}